<?php

//5. Дан код:

class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
$a1 = new A();
$a2 = new A();
$a1->foo();     //1
$a2->foo();     //2
$a1->foo();     //3
$a2->foo();     //4

//Что он выведет на каждом шаге? Почему?
/*
    Переменная $x статическая, а  такие переменныен не исчезают 
    после завершения работы функции. при объявлении статической 
    переменной в функции создается постояннное хранилище, 
    в результате чего статическая переменная запоминает свое 
    последнее значение. 
    Поэтому при вызове метода foo статическая переменная $x 
    будет увеличиваться на единицу и, в данном примере,
    принимать значение 1 2 3 4.   
*/


//Немного изменим п.5:
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A();
$b1 = new B();
$a1->foo();     //1
$b1->foo();     //1
$a1->foo();     //2
$b1->foo();     //2
//6. Объясните результаты в этом случае.
/*
    В данном примере созданы два не зависимых друг от 
    друга объекта (один от класса А, второй от класса В).
    Несмотря на то что по содержанию они одинаковые, 
    при наследовании класс B наследует метод foo со своей 
    собственной статической переменной $x.
    Поэтому при вызове метода foo от разных классов 
    статическая переменная $x будет увеличиваться на единицу 
    в каждом классе отдельнои, в данном примере,
    принимать значение 1 1 2 2.   
*/
//7. *Дан код:
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A;    //нет скобок правильно $a1 = new A();
$b1 = new B;    //нет скобок правильно $b1 = new B();
$a1->foo();     //1
$b1->foo();     //1
$a1->foo();     //2
$b1->foo();     //2
//Что он выведет на каждом шаге? Почему?
/*
    Данный пример отличается от задания 6 тем, что при 
    создании переменных от классов не указаны скобки ().
    Скобки явно вызывают конструктор, поэтому если мы не 
    знаем есть ли у класса конструктор скобки писать надо.
    В данном случае конструктора нет поэтому ошибки 
    не будет и результат будет тот же что и в 6 задании 1 1 2 2.
*/

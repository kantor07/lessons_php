<?php
/* 
	примеры из методички
	Решила написать как конспект для себя, поэтому много комментировала.
*/

/*  
	PHP-скрипт размещаем между тегами <?php..., но второй тег не обязателен
	Классический пример вывода в окно браузера любой фразы (у нас это Hello, World!) при помощи конструкции echo
	Конструкция echo выводит одну или несколько строк в стандартный вывод. 
*/
echo "Hello, World! <br>";


/*  
	Любая переменная в PHP обозначается знаком «$». Переменная в PHP должна состоять из латинских символов (хотя язык 
	допускает имя переменной на других языках) и цифр, не должна содержать спецсимволов, кроме «_», и не может начинаться с числа.
 	Имена переменных в PHP чувствительны к регистру, и $name, $Name, $naMe и так далее это все разные переменные.
 	Если переменную переименовать в $Name = "GeekBrains user1"; , то код не работает
 	Для присвоения значения переменной необходимо воспользоваться оператором =, который позволяет инициализировать переменную
*/
$name = "GeekBrains user";
echo "Hello, $name! <br>"; //выводит "Hello, GeekBrains user"

/*  
	Константам нельзя присвоить (переприсвоить) другое значение - и это их отличие от переменных
	Константы устанавливаются с помощью функции define()
	Обращение к константе происходит без знака «$»
	Правила написания названий констант такие же, как и для переменных, однако, согласно текущим стандартам, константы должны быть написаны заглавными буквами
*/
define('MY_CONST', 100);	
echo MY_CONST . '<br>';		//выводит 100, так как это число установили константе выше

/*  
	Integer - целое число, максимальное значение которого зависит от разрядности операционной системы
	По умолчанию числа задаются в десятеричной системе счисления.
	В восьмиричном числе основанием служит 8, а для выражения всех чисел используются цифры от 0 до 7. Цифра 8 в восьмиричной системе играет ту же роль, что число 10 в десятеричной
	Шестнадцатеричная система счисления (основанием служит число 16) испольхзует цифры от 0 до 9 и букыф английского алфавита от A до F, означающие шестнадцатиричные "цифры" 10, 11, 12, 13, 14 и 15.
	Числа, объявленные в восьмиричной системе счисления, предваряются прфиксом 0, а в шестнадцатеричной - префиксом 0x

	Пример ниже выводит на экран число 42 с помощью переменной типа integer в различных системах счисления
*/
$int10 = 42;
$int2 = 0b101010;
$int8 = 052;
$int16 = 0x2A;
echo "Десятеричная система $int10 <br>";
echo "Двоичная система $int2 <br>";
echo "Восьмеричная система $int8 <br>";
echo "Шестнадцатеричная система $int16 <br>";


/*
	Вещественные числа (float или double) позволяют сохранить данные в огромном интервале.
	Размер числа с плавающей точкой зависит от платформы. 
	Максимально возможное значение, как правило, составляет ~1.8e308 с точностью около 14 десятичных цифр. 
*/
$precise1 = 1.5;		//стандартная запись объявления положительного вещественного числа
$precise2 = 1.5e4;		//объявление положительного вещественного числа больше единицы
$precise3 = 6E-8;		//объявление положительного вещественного числа меньше единицы
echo "$precise1 | $precise2 | $precise3 <br>"; //выводит значения заданные переменным выше

/*
	Строки предназначены для хранения текстовой информации. Объявление строк происходит при помощи кавычек. 
	Кавычки используют двойные и одинарные. Тип кавычек определяет обработку строк интерпретатором.
*/
$a = 1;
echo "$a <br>";		//вместо переменных в этих кавычках в PHP подставляются их значения, выводит 1
echo '$a <br>';		//вместо переменных в PHP не подставляется их значения, символ S отображается как есть, выводит $a

/*
	Приведение типов в PHP работает так же, как и в C: имя требуемого типа записывается в круглых скобках перед приводимой переменной.
*/
$a = 10;			//это целое число			
$b = (boolean) $b;	//$b - булиев тип

//выводит 10, так как это целое число у меня выдает ошибку в консоли, наверное потому что в переменной $b ничего не присвоено
echo "$a | $b <br>";	

//boolean рассматривает саму себя как false
var_dump((bool) $b);
/*
	В PHP можно объединить несколько строк в одну с помощью конкатенации. Конкатенация в языке PHP выполняется с помощью символа точка (.). При выполнении данной операции все переменные других типов, если это возможно, будут приведены к строковому типу. согласно стандартам при конкатенации двух строк, справа и слева от точки должны быть пробелы.
*/
$a = '<br> Hello,';
$b = 'world';
$c = $a . $b;
echo $c . '<br>';	//выводит "Hello, world"

/*
	Прочитала, что помимо оператора точка существует оператор .=, который предназначен для сокращения конструкции "результат = строка . строка . строка и тд" до "результат .= новая строка (из всех ранее перечисленных)". 
	Незнаю насколько это удобно применять в работе, но попробовала переписать пример из методички
*/
$str = 'Hello,';
$str .= 'world';
$str .= '!';
echo $str . '<br>';		//так же выводит "Hello, world!"


/*
	Арифметические операторы проделывают вполне ожидаемую работу. Они применяются для выполнения математических операций. 
	Их можно использовать для проведения четырех основных операций (сложения, вычитания, умножения и деления), а также для остатка от деления и увеличения или уменьшения значения на единицу 
*/
$a = 4;
$b = 5;
echo $a + $b . '<br>';    	// сложение, выводит 9
echo $a * $b . '<br>';    	// умножение, выводит 20
echo $a - $b . '<br>'; 		// вычитание, выводит -1
echo $a / $b . '<br>';  	// деление, выводит 0.8
// остаток от деления, выводит 4, так как если делимое меньше делителя, то частное равно нулю, а остаток равен делимому
echo $a % $b . '<br>'; 		
echo $a ** $b . '<br>'; 	// возведение в степень, выводит 1024

/*
	 PHP поддерживает префиксные и постфиксные операторы инкремента и декремента в стиле C.
	 ???Операторы инкремента/декремента влияют только на строки и числа. Массивы, объекты и ресурсы не трогаются. 
	 ???Декремент NULL также не даст никакого эффекта, однако инкремент даст значение 1. 
*/
$a = 4;
$b = 5;
$a += $b;					//суммируем 4 + 5 и записываем в переменную a
echo 'a = ' . $a . '<br>';	// выводит a = 9
$a = 0;						//присваиваем a = 0
echo $a++ . '<br>'; 		// Постинкремент - возвращает значение $a, затем увеличивает $a на единицу. Теперь $a равно 1
echo ++$a . '<br>'; 		// Преинкремент - увеличивает $a на единицу, затем возвращает значение $a. Теперь $a равно 2
echo $a-- . '<br>'; 		// Постдекремент - возвращает значение $a, затем уменьшает $a на единицу. Теперь $a равна 1
echo --$a . '<br>'; 		// Предекремент - уменьшает $a на единицу, затем возвращает значение $a. Теперь  $a равна 0

/*
	В PHP операторы сравнивают заданные значения и возвращают true или false. Исключение составляет лишь оператор <=>, который возвращает целое число.
*/

$a = 4;
$b = 5;
// Сравнение по значению возвращает true, если значение переменной $a равно $b 
var_dump($a == $b);  	//вернет false, так как значение переменной $a  не равно $b 
// Сравнение по значению и типу, возвращает true, если значение и тип переменной $a равно $b 
var_dump($a === $b); 	// вернет false, так как значение переменной $a не равно $b 
// Больше, возвращает true, если переменная $a имеет значение строго больше, чем значение $b 
var_dump($a > $b); 		// false, так как переменная $a имеет значение строго меньше, чем значение $b
// Меньше, возвращает true, если переменная $a имеет значение строго меньше, чем значение $b 
var_dump($a < $b);  	// вернет true, так как переменная $a имеет значение строго меньше, чем значение $b 
// Не равно - эквивалентен оператору !=
var_dump($a <> $b); 	//вернет true, так как значение переменной $a не равно $b
// Не равно, возвращает true, если значение переменной $a не равно $b
var_dump($a != $b);   	// вернет true, так как значение переменной $a не равно $b
// Не равно без приведения типов, оператор неэквивалентности, возвращает true, если либо значение, либо тип переменной $a не 
// соответствует переменной $b	
var_dump($a !== $b); 	// вернет true, так как значение переменной $a не соответствует переменной $b	
// Меньше или равно, возвращает true, если переменная $a имеет значение меньше или равное $b
var_dump($a <= $b);  	// вернет true, так как переменная $a имеет значение меньше $b
// Больше или равно, возвращает true, если переменная $a имеет значение больше или равное $b
var_dump($a >= $b);  	//вернет false, так как переменная $a имеет значение меньше $b
/*
	В случае равенства переменных оператор возвращает 0, если $a больше $b возвращает положительное число, если меньше - отрицательное
*/
var_dump($a<=>$b); 		// вернет отрицательное число (-1), так как переменная $a меньше $b